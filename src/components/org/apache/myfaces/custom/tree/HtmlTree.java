/*
 * Copyright 2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.sourceforge.myfaces.custom.tree;

import java.io.IOException;
import java.util.*;
import javax.faces.component.UIViewRoot;
import javax.faces.context.FacesContext;
import javax.faces.el.ValueBinding;

import net.sourceforge.myfaces.custom.tree.event.TreeSelectionEvent;
import net.sourceforge.myfaces.custom.tree.event.TreeSelectionListener;
import net.sourceforge.myfaces.custom.tree.model.TreeModel;
import net.sourceforge.myfaces.custom.tree.model.TreeModelEvent;
import net.sourceforge.myfaces.custom.tree.model.TreeModelListener;
import net.sourceforge.myfaces.custom.tree.model.TreePath;
import net.sourceforge.myfaces.component.html.ext.HtmlPanelGroup;


/**
 * <p>Tree implementation based on javax.swing.JTree.</p>
 * <p>The tree model is assigned by using a value binding named <code>model</code> and is not
 * stored in view state.</p>
 * <p>A hierarchy of {@link HtmlTreeNode} objects is used to represent the current
 * expanded state of the tree. The root node is held as a faces named <code>rootNode</code>.</p>
 *
 * @author <a href="mailto:oliver@rossmueller.com">Oliver Rossmueller</a>
 * @version $Revision$ $Date$
 *          $Log$
 *          Revision 1.21  2004/09/01 18:32:54  mwessendorf
 *          Organize Imports
 *
 *          Revision 1.20  2004/08/15 15:28:04  o_rossmueller
 *          new model listener handling to get modified from events which occur outside the scope of a tree request
 *
 *          Revision 1.19  2004/07/26 22:55:10  o_rossmueller
 *          use ids instead of clientIds
 *          <p/>
 *          Revision 1.18  2004/07/25 11:08:02  o_rossmueller
 *          use HtmlTree class name for PREVIOUS_VIEW_ROOT constant
 *          <p/>
 *          Revision 1.17  2004/07/25 11:06:38  o_rossmueller
 *          made default image paths relative (again)
 *          <p/>
 *          Revision 1.16  2004/07/18 21:39:34  o_rossmueller
 *          fix #992452: child icon attributes are restored correctly
 *          <p/>
 *          Revision 1.15  2004/07/18 21:36:27  o_rossmueller
 *          fix #991740: getResourceURL for tree image urls
 *          <p/>
 *          Revision 1.14  2004/07/11 23:38:57  o_rossmueller
 *          support multiple trees in one view
 *          <p/>
 *          Revision 1.13  2004/07/01 21:53:07  mwessendorf
 *          ASF switch
 *          <p/>
 *          Revision 1.12  2004/05/12 02:27:43  o_rossmueller
 *          fix #951896: tree component works for JAVASCRIPT=false, too
 *          <p/>
 *          Revision 1.11  2004/05/10 01:24:51  o_rossmueller
 *          added iconClass attribute
 *          <p/>
 *          Revision 1.10  2004/05/05 00:18:57  o_rossmueller
 *          various fixes/modifications in model event handling and tree update
 *          <p/>
 *          Revision 1.9  2004/05/04 12:19:14  o_rossmueller
 *          added icon provider
 *          <p/>
 *          Revision 1.8  2004/05/04 00:28:17  o_rossmueller
 *          model event handling
 *          <p/>
 *          Revision 1.7  2004/04/29 18:48:16  o_rossmueller
 *          node selection handling
 *          <p/>
 *          Revision 1.6  2004/04/23 19:09:34  o_rossmueller
 *          state transition magic
 *          <p/>
 *          Revision 1.5  2004/04/22 23:22:33  o_rossmueller
 *          fix: queueEvent
 *          <p/>
 *          Revision 1.4  2004/04/22 22:00:30  o_rossmueller
 *          implemented HtmlTree.expandPath
 *          <p/>
 *          Revision 1.3  2004/04/22 21:14:55  o_rossmueller
 *          TreeSelectionListener support
 *          <p/>
 *          Revision 1.2  2004/04/22 13:00:09  o_rossmueller
 *          changed id creation - node ids are now generated by tree
 *          <p/>
 *          Revision 1.1  2004/04/22 10:20:23  manolito
 *          tree component
 */
public class HtmlTree
    extends HtmlPanelGroup
    implements TreeModelListener
{

    public static final int DEFAULT_EXPIRE_LISTENERS = 8 * 60 * 60 * 1000; // 8 hours


    private static final String FACET_ROOTNODE = "rootNode";
    private static final String PREVIOUS_VIEW_ROOT = HtmlTree.class.getName() + ".PREVIOUS_VIEW_ROOT";

    private static final int EVENT_CHANGED = 0;
    private static final int EVENT_INSERTED = 1;
    private static final int EVENT_REMOVED = 2;
    private static final int EVENT_STRUCTURE_CHANGED = 3;

    private static int counter = 0;


    private IconProvider iconProvider;
    private boolean itemStatesRestored = false;
    private String styleClass;
    private String nodeClass;
    private String selectedNodeClass;
    private String iconClass;
    private String iconLine = "images/tree/line.gif";
    private String iconNoline = "images/tree/noline.gif";
    private String iconChild = "images/tree/noline.gif";
    private String iconChildFirst = "images/tree/line_first.gif";
    private String iconChildMiddle = "images/tree/line_middle.gif";
    private String iconChildLast = "images/tree/line_last.gif";
    private String iconNodeOpen = "images/tree/node_open.gif";
    private String iconNodeOpenFirst = "images/tree/node_open_first.gif";
    private String iconNodeOpenMiddle = "images/tree/node_open_middle.gif";
    private String iconNodeOpenLast = "images/tree/node_open_last.gif";
    private String iconNodeClose = "images/tree/node_close.gif";
    private String iconNodeCloseFirst = "images/tree/node_close_first.gif";
    private String iconNodeCloseMiddle = "images/tree/node_close_middle.gif";
    private String iconNodeCloseLast = "images/tree/node_close_last.gif";
    private int uniqueIdCounter = 0;
    private int[] selectedPath;
    private int internalId;
    private long expireListeners = DEFAULT_EXPIRE_LISTENERS;


    public HtmlTree()
    {
        internalId = counter++;
    }


    public TreeModel getModel(FacesContext context)
    {
        ValueBinding binding = getValueBinding("model");

        if (binding != null)
        {
            TreeModel model = (TreeModel) binding.getValue(context);
            if (model != null)
            {
                return model;
            }
        }
        return null;
    }


    public String createUniqueId(FacesContext context)
    {
        return getClientId(context) + "_node_" + uniqueIdCounter++;
    }


    public void addTreeSelectionListener(TreeSelectionListener listener)
    {
        addFacesListener(listener);
    }


    public IconProvider getIconProvider()
    {
        return iconProvider;
    }


    public void setIconProvider(IconProvider iconProvider)
    {
        this.iconProvider = iconProvider;
    }


    public String getIconLine()
    {
        return iconLine;
    }


    public void setIconLine(String iconLine)
    {
        this.iconLine = iconLine;
    }


    public String getIconNoline()
    {
        return iconNoline;
    }


    public void setIconNoline(String iconNoline)
    {
        this.iconNoline = iconNoline;
    }


    public String getIconChild()
    {
        return iconChild;
    }


    public void setIconChild(String iconChild)
    {
        this.iconChild = iconChild;
    }


    public String getIconChildFirst()
    {
        return iconChildFirst;
    }


    public void setIconChildFirst(String iconChildFirst)
    {
        this.iconChildFirst = iconChildFirst;
    }


    public String getIconChildMiddle()
    {
        return iconChildMiddle;
    }


    public void setIconChildMiddle(String iconChildMiddle)
    {
        this.iconChildMiddle = iconChildMiddle;
    }


    public String getIconChildLast()
    {
        return iconChildLast;
    }


    public void setIconChildLast(String iconChildLast)
    {
        this.iconChildLast = iconChildLast;
    }


    public String getIconNodeOpen()
    {
        return iconNodeOpen;
    }


    public void setIconNodeOpen(String iconNodeOpen)
    {
        this.iconNodeOpen = iconNodeOpen;
    }


    public String getIconNodeOpenFirst()
    {
        return iconNodeOpenFirst;
    }


    public void setIconNodeOpenFirst(String iconNodeOpenFirst)
    {
        this.iconNodeOpenFirst = iconNodeOpenFirst;
    }


    public String getIconNodeOpenMiddle()
    {
        return iconNodeOpenMiddle;
    }


    public void setIconNodeOpenMiddle(String iconNodeOpenMiddle)
    {
        this.iconNodeOpenMiddle = iconNodeOpenMiddle;
    }


    public String getIconNodeOpenLast()
    {
        return iconNodeOpenLast;
    }


    public void setIconNodeOpenLast(String iconNodeOpenLast)
    {
        this.iconNodeOpenLast = iconNodeOpenLast;
    }


    public String getIconNodeClose()
    {
        return iconNodeClose;
    }


    public void setIconNodeClose(String iconNodeClose)
    {
        this.iconNodeClose = iconNodeClose;
    }


    public String getIconNodeCloseFirst()
    {
        return iconNodeCloseFirst;
    }


    public void setIconNodeCloseFirst(String iconNodeCloseFirst)
    {
        this.iconNodeCloseFirst = iconNodeCloseFirst;
    }


    public String getIconNodeCloseMiddle()
    {
        return iconNodeCloseMiddle;
    }


    public void setIconNodeCloseMiddle(String iconNodeCloseMiddle)
    {
        this.iconNodeCloseMiddle = iconNodeCloseMiddle;
    }


    public String getIconNodeCloseLast()
    {
        return iconNodeCloseLast;
    }


    public void setIconNodeCloseLast(String iconNodeCloseLast)
    {
        this.iconNodeCloseLast = iconNodeCloseLast;
    }


    public String getStyleClass()
    {
        return styleClass;
    }


    public void setStyleClass(String styleClass)
    {
        this.styleClass = styleClass;
    }


    public String getNodeClass()
    {
        return nodeClass;
    }


    public void setNodeClass(String nodeClass)
    {
        this.nodeClass = nodeClass;
    }


    public String getSelectedNodeClass()
    {
        return selectedNodeClass;
    }


    public void setSelectedNodeClass(String selectedNodeClass)
    {
        this.selectedNodeClass = selectedNodeClass;
    }


    public String getIconClass()
    {
        return iconClass;
    }


    public void setIconClass(String iconClass)
    {
        this.iconClass = iconClass;
    }


    public long getExpireListeners()
    {
        return expireListeners;
    }


    public void setExpireListeners(long expireListeners)
    {
        this.expireListeners = expireListeners;
    }


    public String getFamily()
    {
        return "net.sourceforge.myfaces.HtmlTree";
    }


    /**
     * Ensures that the node identified by the specified path is
     * expanded and viewable. If the last item in the path is a
     * leaf, this will have no effect.
     *
     * @param path the <code>TreePath</code> identifying a node
     */
    public void expandPath(TreePath path, FacesContext context)
    {
        // Only expand if not leaf!
        TreeModel model = getModel(context);

        if (path != null && model != null && !model.isLeaf(path.getLastPathComponent()))
        {
            int[] translatedPath = HtmlTreeNode.translatePath(path, getModel(context));
            HtmlTreeNode rootNode = getRootNode();
            if (rootNode == null)
            {
                createRootNode(context);
                rootNode = getRootNode();
            }
            if (!rootNode.isExpanded())
            {
                rootNode.setExpanded(true);
            }
            rootNode.expandPath(translatedPath, 0);

        }
    }


    /**
     * Ensures that the node identified by the specified path is
     * collapsed and viewable.
     *
     * @param path the <code>TreePath</code> identifying a node
     */
    public void collapsePath(TreePath path, FacesContext context)
    {
        HtmlTreeNode node = findNode(path, context);

        if (node != null)
        {
            node.setExpanded(false);
        }
    }


    public boolean isExpanded(TreePath path, FacesContext context)
    {
        if (path == null)
        {
            return false;
        }

        return findNode(path, context) != null;
    }


    private HtmlTreeNode findNode(TreePath path, FacesContext context)
    {
        HtmlTreeNode node = getRootNode();
        int[] translatedPath = HtmlTreeNode.translatePath(path, getModel(context));

        for (int i = 0; i < translatedPath.length; i++)
        {
            if (!node.isExpanded())
            {
                return null;
            }
            int index = translatedPath[i];
            node = (HtmlTreeNode) node.getChildren().get(index);
        }
        return node;
    }


    public TreePath getSelectionPath()
    {
        if (selectedPath == null)
        {
            return null;
        }
        return HtmlTreeNode.translatePath(selectedPath, getModel(FacesContext.getCurrentInstance()));
    }


    public void selectionChanged(HtmlTreeNode node)
    {
        TreePath oldPath = null;

        if (selectedPath != null)
        {
            oldPath = HtmlTreeNode.translatePath(selectedPath, getModel(FacesContext.getCurrentInstance()));
        }
        selectedPath = node.getTranslatedPath();
        if (node.isSelected())
        {
            queueEvent(new TreeSelectionEvent(this, oldPath, node.getPath()));
        } else
        {
            queueEvent(new TreeSelectionEvent(this, oldPath, null));
        }
    }


    private void createRootNode(FacesContext context)
    {
        HtmlTreeNode node;
        TreeModel model = getModel(context);
        Object root = model.getRoot();
        node = (HtmlTreeNode) context.getApplication().createComponent(HtmlTreeNode.COMPONENT_TYPE);
        String id = createUniqueId(context);
        node.setId(id);

        node.setPath(new TreePath(new Object[]{root}));
        node.setUserObject(root);
        node.setLayout(new int[]{HtmlTreeNode.CLOSED_SINGLE});
        getFacets().put(FACET_ROOTNODE, node);
    }


    public HtmlTreeNode getRootNode()
    {
        return (HtmlTreeNode) getFacet(FACET_ROOTNODE);
    }


    public Object saveState(FacesContext context)
    {
        Object values[] = new Object[22];
        values[0] = super.saveState(context);
        values[1] = iconChild;
        values[2] = iconChildFirst;
        values[3] = iconChildLast;
        values[4] = iconLine;
        values[5] = iconNodeClose;
        values[6] = iconNodeCloseFirst;
        values[7] = iconNodeCloseLast;
        values[8] = iconNodeCloseMiddle;
        values[9] = iconNodeOpen;
        values[10] = iconNodeOpenFirst;
        values[11] = iconNodeOpenLast;
        values[12] = iconNodeOpenMiddle;
        values[13] = iconNoline;
        values[14] = styleClass;
        values[15] = nodeClass;
        values[16] = selectedNodeClass;
        values[17] = new Integer(uniqueIdCounter);
        values[18] = selectedPath;
        values[19] = iconClass;
        values[20] = new Integer(internalId);
        values[21] = new Long(expireListeners);
        return ((Object) (values));
    }


    public void restoreState(FacesContext context, Object state)
    {
        Object values[] = (Object[]) state;
        super.restoreState(context, values[0]);
        iconChild = (String) values[1];
        iconChildFirst = (String) values[2];
        iconChildLast = (String) values[3];
        iconLine = (String) values[4];
        iconNodeClose = (String) values[5];
        iconNodeCloseFirst = (String) values[6];
        iconNodeCloseLast = (String) values[7];
        iconNodeCloseMiddle = (String) values[8];
        iconNodeOpen = (String) values[9];
        iconNodeOpenFirst = (String) values[10];
        iconNodeOpenLast = (String) values[11];
        iconNodeOpenMiddle = (String) values[12];
        iconNoline = (String) values[13];
        styleClass = (String) values[14];
        nodeClass = (String) values[15];
        selectedNodeClass = (String) values[16];
        uniqueIdCounter = ((Integer) values[17]).intValue();
        selectedPath = (int[]) values[18];
        iconClass = (String) values[19];
        internalId = ((Integer) values[20]).intValue();
        expireListeners = ((Long) values[21]).longValue();
        addToModelListeners();
    }


    public void decode(FacesContext context)
    {
        super.decode(context);

        //Save the current view root for later reference...
        context.getExternalContext().getRequestMap().put(PREVIOUS_VIEW_ROOT, context.getViewRoot());
        //...and remember that this instance needs NO special treatment on rendering:
        itemStatesRestored = true;
    }


    public void processDecodes(FacesContext context)
    {
        addToModelListeners();
        super.processDecodes(context);
    }


    public void processValidators(FacesContext context)
    {
        addToModelListeners();
        super.processValidators(context);
    }


    public void processUpdates(FacesContext context)
    {
        addToModelListeners();
        super.processUpdates(context);
    }


    public void encodeBegin(FacesContext context) throws IOException
    {
        addToModelListeners();
        processModelEvents();

        HtmlTreeNode node = getRootNode();

        if (node == null)
        {
            createRootNode(context);
        }

        if (!itemStatesRestored)
        {
            UIViewRoot previousRoot = (UIViewRoot) context.getExternalContext().getRequestMap().get(PREVIOUS_VIEW_ROOT);
            if (previousRoot != null)
            {
                restoreItemStates(context, previousRoot);
            } else
            {
                //no previous root, means no decode was done
                //--> a new request
            }
        }

        super.encodeBegin(context);
    }


    public void encodeEnd(FacesContext context) throws IOException
    {
        super.encodeEnd(context);
    }


    public void restoreItemStates(FacesContext facesContext, UIViewRoot previousRoot)
    {
        HtmlTree previousTree = (HtmlTree) previousRoot.findComponent(getClientId(facesContext));

        if (previousTree != null)
        {
            HtmlTreeNode node = previousTree.getRootNode();

            if (node != null)
            {
                getRootNode().restoreItemState(node);
            }

            selectedPath = previousTree.selectedPath;
        }
    }


    public void treeNodesChanged(TreeModelEvent e)
    {
        TreePath path = e.getTreePath();
        FacesContext context = FacesContext.getCurrentInstance();
        HtmlTreeNode node = findNode(path, context);

        if (node != null)
        {
            node.childrenChanged(e.getChildIndices(), context);
        }
    }


    public void treeNodesInserted(TreeModelEvent e)
    {
        TreePath path = e.getTreePath();
        FacesContext context = FacesContext.getCurrentInstance();
        HtmlTreeNode node = findNode(path, context);

        if (node != null)
        {
            node.childrenAdded(e.getChildIndices(), context);
        }
    }


    public void treeNodesRemoved(TreeModelEvent e)
    {
        TreePath path = e.getTreePath();
        FacesContext context = FacesContext.getCurrentInstance();
        HtmlTreeNode node = findNode(path, context);

        if (node != null)
        {
            node.childrenRemoved(e.getChildIndices());
        }
    }


    public void treeStructureChanged(TreeModelEvent e)
    {
        TreePath path = e.getTreePath();
        FacesContext context = FacesContext.getCurrentInstance();

        if (isExpanded(path, context))
        {
            collapsePath(path, context);
            expandPath(path, context);
        }
    }


    public boolean equals(Object obj)
    {
        if (!(obj instanceof HtmlTree))
        {
            return false;
        }
        HtmlTree other = (HtmlTree) obj;

        return other.getId().equals(getId());
    }


    public int hashCode()
    {
        return getClientId(FacesContext.getCurrentInstance()).hashCode();
    }


    public void addToModelListeners()
    {
        Collection listeners = getModel(FacesContext.getCurrentInstance()).getTreeModelListeners();
        long currentTime = System.currentTimeMillis();
        boolean found = false;

        for (Iterator iterator = listeners.iterator(); iterator.hasNext();)
        {
            ModelListener listener = (ModelListener) iterator.next();

            if (listener.getId() == internalId)
            {
                found = true;
            } else if (currentTime - listener.getLastAccessTime() > expireListeners)
            {
                iterator.remove();
            }
        }
        if (!found)
        {
            listeners.add(new ModelListener(internalId));
        }
    }


    private void processModelEvents()
    {
        Collection listeners = getModel(FacesContext.getCurrentInstance()).getTreeModelListeners();

        for (Iterator iterator = listeners.iterator(); iterator.hasNext();)
        {
            ModelListener listener = (ModelListener) iterator.next();

            if (listener.getId() == internalId)
            {
                for (Iterator events = listener.getEvents().iterator(); events.hasNext();)
                {
                    Event event = (Event) events.next();
                    event.process(this);
                    events.remove();
                }
                break;
            }
        }
    }


    private static class ModelListener implements TreeModelListener
    {

        private long lastAccessTime = System.currentTimeMillis();
        private LinkedList events = new LinkedList();
        int id;


        public ModelListener(int id)
        {
            this.id = id;
        }


        public List getEvents()
        {
            lastAccessTime = System.currentTimeMillis();
            return events;
        }


        public int getId()
        {
            return id;
        }


        public long getLastAccessTime()
        {
            return lastAccessTime;
        }


        public void treeNodesChanged(TreeModelEvent e)
        {
            events.addLast(new Event(EVENT_CHANGED, e));
        }


        public void treeNodesInserted(TreeModelEvent e)
        {
            events.addLast(new Event(EVENT_INSERTED, e));
        }


        public void treeNodesRemoved(TreeModelEvent e)
        {
            events.addLast(new Event(EVENT_REMOVED, e));
        }


        public void treeStructureChanged(TreeModelEvent e)
        {
            events.addLast(new Event(EVENT_STRUCTURE_CHANGED, e));
        }
    }


    private static class Event
    {

        private int kind;
        private TreeModelEvent event;


        public Event(int kind, TreeModelEvent event)
        {
            this.kind = kind;
            this.event = event;
        }


        public void process(HtmlTree tree)
        {
            switch (kind)
            {
                case EVENT_CHANGED:
                    tree.treeNodesChanged(event);
                    break;
                case EVENT_INSERTED:
                    tree.treeNodesInserted(event);
                    break;
                case EVENT_REMOVED:
                    tree.treeNodesRemoved(event);
                    break;
                case EVENT_STRUCTURE_CHANGED:
                    tree.treeStructureChanged(event);
                    break;
            }
        }
    }
}
